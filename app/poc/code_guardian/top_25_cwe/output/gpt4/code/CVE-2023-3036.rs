fn parse_extensions(buff: &[u8]) -> Result<Vec<NtpExtension>, std::io::Error> {
    let mut reader = Cursor::new(buff);
    let mut retval = Vec::new();
    while buff.len() - reader.position() as usize >= 4 {
        let ext_type = reader.read_u16::<BigEndian>()?;
        let ext_len = reader.read_u16::<BigEndian>()?;
        if ext_len % 4 != 0 {
            return Err(Error::new(
                ErrorKind::InvalidInput,
                "extension not on word boundary",
            ));
        }
        if ext_len < 4 {
            return Err(Error::new(ErrorKind::InvalidInput, "extension too short"));
        }
        let mut contents: Vec<u8> = vec![0; (ext_len - 4) as usize];
        reader.read_exact(&mut contents)?;
        retval.push(NtpExtension {
            ext_type: type_from_wire(ext_type),
            contents: contents,
        })
    }
    Ok(retval)
}

pub fn parse_nts_packet<T: Aead>(
    buff: &[u8],
    decryptor: &mut T,
) -> Result<NtsPacket, std::io::Error> {
    let header = parse_packet_header(buff)?;
    let mut reader = Cursor::new(buff);
    let mut auth_exts = Vec::new();
    reader.set_position(HEADER_SIZE);
    while buff.len() - reader.position() as usize >= 4 {
        let ext_type = reader.read_u16::<BigEndian>()?;
        let ext_len = (reader.read_u16::<BigEndian>()? - 4) as usize; // RFC 7822
        if ext_len > buff.len() - reader.position() as usize {
            return Err(Error::new(ErrorKind::InvalidInput, "extension length exceeds buffer"));
        }
        match type_from_wire(ext_type) {
            NTSAuthenticator => {
                let mut auth_ext_contents = vec![0; ext_len];
                reader.read_exact(&mut auth_ext_contents)?;
                let oldpos = (reader.position() - 4 - (ext_len as u64)) as usize;
                let enc_ext_data =
                    parse_decrypt_auth_ext::<T>(&buff[0..oldpos], &auth_ext_contents, decryptor)?;
                let enc_exts = parse_extensions(&enc_ext_data)?;
                return Ok(NtsPacket {
                    header: header,
                    auth_exts: auth_exts,
                    auth_enc_exts: enc_exts,
                });
            }
            _ => {
                let mut contents: Vec<u8> = vec![0; ext_len];
                reader.read_exact(&mut contents)?;
                auth_exts.push(NtpExtension {
                    ext_type: type_from_wire(ext_type),
                    contents: contents,
                });
            }
        }
    }
    return Err(Error::new(
        ErrorKind::InvalidInput,
        "never saw the authenticator",
    ));
}

