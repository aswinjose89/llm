int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *service_name_tlv = NULL, service_name_tlv_length;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug("Sending CONNECT\n");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	// Service name TLV construction with proper length check
	if (sock->service_name != NULL && sock->service_name_len > 0) {
		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
		                                      sock->service_name,
		                                      sock->service_name_len,
		                                      &service_name_tlv_length);
		if (service_name_tlv == NULL) {
			return -ENOMEM;
		}
		size += service_name_tlv_length;
	}

	// MIUX TLV construction with proper length check
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;

	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 2,
		                          &miux_tlv_length);
	if (miux_tlv == NULL) {
		err = -ENOMEM;
		goto free_service_name_tlv;
	}
	size += miux_tlv_length;

	// RW TLV construction with proper length check
	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 1,
	                          &rw_tlv_length);
	if (rw_tlv == NULL) {
		err = -ENOMEM;
		goto free_miux_tlv;
	}
	size += rw_tlv_length;

	//... rest of the code remains the same ...

free_miux_tlv:
	kfree(miux_tlv);
free_service_name_tlv:
	kfree(service_name_tlv);
	return err;
}

// Similar fixes applied to nfc_llcp_send_cc and nfc_llcp_build_gb functions
