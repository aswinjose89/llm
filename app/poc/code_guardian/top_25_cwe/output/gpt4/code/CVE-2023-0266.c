static int snd_ctl_elem_read(struct snd_card* card,
			struct snd_ctl_elem_value* control)
{
	struct snd_kcontrol* kctl;
	struct snd_kcontrol_volatile* vd;
	unsigned int index_offset;
	struct snd_ctl_elem_info info;
	int ret;

	kctl = snd_ctl_find_id(card, &control->id);
	if (kctl == NULL)
		return -ENOENT;

	index_offset = snd_ctl_get_ioff(kctl, &control->id);
	vd = &kctl->vd[index_offset];
	if (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)
		return -EPERM;

	snd_ctl_build_ioff(&control->id, kctl, index_offset);

	memset(&info, 0, sizeof(info));
	info.id = control->id;
	ret = kctl->info(kctl, &info);
	if (ret < 0)
		return ret;

	snd_ctl_skip_validation(kctl, &info);

	ret = snd_power_ref_and_wait(card);
	if (!ret)
		ret = kctl->get(kctl, control);
	snd_power_unref(card);
	if (ret < 0)
		return ret;

	if (!snd_ctl_skip_validation(&info) &&
	    snd_ctl_sanitize_elem_value(card, control, &info) < 0) {
		dev_err(card->dev,
			"control %i:%i:%i:%s:%i: invalid element value\n",
			control->id.iface, control->id.device,
			control->id.subdevice, control->id.name,
			control->id.index);
		return -EINVAL;
	}
	return ret;
}