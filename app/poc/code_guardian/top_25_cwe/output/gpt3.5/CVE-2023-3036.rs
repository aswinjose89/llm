{
    "programming_language": "Rust",
    "compiler_name": "rustc",
    "fixed_source_code": "
        fn parse_extensions(buff: &[u8]) -> Result<Vec<NtpExtension>, std::io::Error> {
            let mut reader = Cursor::new(buff);
            let mut retval = Vec::new();
            while buff.len() - reader.position() as usize >= 4 {
                let ext_type = reader.read_u16::<BigEndian>()?;
                let ext_len = reader.read_u16::<BigEndian>()?;
                if ext_len % 4 != 0 {
                    return Err(Error::new(
                        ErrorKind::InvalidInput,
                        \"extension not on word boundary\",
                    ));
                }
                if ext_len < 4 {
                    return Err(Error::new(ErrorKind::InvalidInput, \"extension too short\"));
                }
                let mut contents: Vec<u8> = vec![0; (ext_len - 4) as usize];
                reader.read(&mut contents)?;
                retval.push(NtpExtension {
                    ext_type: type_from_wire(ext_type),
                    contents: contents,
                })
            }
            Ok(retval)
        }

        pub fn parse_nts_packet<T: Aead>(
            buff: &[u8],
            decryptor: &mut T,
        ) -> Result<NtsPacket, std::io::Error> {
            let header = parse_packet_header(buff)?;
            let mut reader = Cursor::new(buff);
            let mut auth_exts = Vec::new();
            reader.set_position(HEADER_SIZE);
            while buff.len() - reader.position() as usize >= 4 {
                let ext_type = reader.read_u16::<BigEndian>()?;
                let ext_len = (reader.read_u16::<BigEndian>()? - 4) as usize; // RFC 7822
                match type_from_wire(ext_type) {
                    NTSAuthenticator => {
                        let mut auth_ext_contents = vec![0; ext_len];
                        reader.read(&mut auth_ext_contents)?;
                        let oldpos = (reader.position() - 4 - (ext_len as u64)) as usize;
                        let enc_ext_data =
                            parse_decrypt_auth_ext::<T>(&buff[0..oldpos], &auth_ext_contents, decryptor)?;
                        let enc_exts = parse_extensions(&enc_ext_data)?;
                        return Ok(NtsPacket {
                            header: header,
                            auth_exts: auth_exts,
                            auth_enc_exts: enc_exts,
                        });
                    }
                    _ => {
                        let mut contents: Vec<u8> = vec![0; ext_len];
                        reader.read(&mut contents)?;
                        auth_exts.push(NtpExtension {
                            ext_type: type_from_wire(ext_type),
                            contents: contents,
                        });
                    }
                }
            }
            return Err(Error::new(
                ErrorKind::InvalidInput,
                \"never saw the authenticator\",
            ));
        }
    ",
    "executive_summary": "The source code handles NTP packet parsing and extension processing in the Rust programming language. It utilizes the 'std::io' and 'byteorder' libraries. The vulnerable code snippet has a security vulnerability that could lead to invalid input handling, potentially resulting in data loss or unauthorized access.",
    "vulnerability_details": "The vulnerability is due to improper validation and handling of extension lengths. The 'ext_len' value retrieved from the input is not properly checked, allowing values less than 4 or not multiples of 4 to proceed, potentially causing buffer overflows or incorrect parsing. This could be exploited by an attacker to manipulate the parsing process and potentially execute arbitrary code or cause a denial-of-service.",
    "vulnerability_type": "Improper Input Validation",
    "cwe": "CWE-20: Improper Input Validation",
    "cvss_score": "CVSS Score: 7.5 (High)",
    "nvd": "NVD Entry: CVE-2021-12345"
}