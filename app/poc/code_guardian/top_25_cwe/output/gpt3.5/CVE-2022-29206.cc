{
  "programming_language": "C++",
  "compiler_name": "Unknown",
  "fixed_source_code": "namespace {\n\n  template <typename Index>\n  Status ValidateInputs(const Tensor* a_indices, const Tensor* a_values, const Tensor* a_shape, const Tensor* b) {\n    if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n      return errors::InvalidArgument(\n          \"Input a_indices should be a matrix but received shape: \",\n          a_indices->shape().DebugString());\n    }\n    if (!TensorShapeUtils::IsVector(a_values->shape()) || !TensorShapeUtils::IsVector(a_shape->shape())) {\n      return errors::InvalidArgument(\n          \"Inputs a_values and a_shape should be vectors but received shapes: \",\n          a_values->shape().DebugString(), \" and \",\n          a_shape->shape().DebugString());\n    }\n    if (a_shape->NumElements() != b->dims()) {\n      return errors::InvalidArgument(\n          \"Two operands have different ranks; received: \", a_shape->NumElements(),\n          \" and \", b->dims());\n    }\n    const auto a_shape_flat = a_shape->flat<Index>();\n    for (int i = 0; i < b->dims(); ++i) {\n      if (a_shape_flat(i) != b->dim_size(i)) {\n        return errors::InvalidArgument(\n            \"Dimension \", i,\n            \" does not equal (no broadcasting is supported): sparse side \",\n            a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n      }\n    }\n    return Status::OK();\n  }\n\n}",
  "executive_summary": "The source code contains vulnerabilities that may lead to security breaches and data loss.",
  "vulnerability_details": "The source code does not properly validate inputs, potentially allowing for unexpected behavior and security vulnerabilities.",
  "vulnerability_type": "Input Validation",
  "cwe": "CWE-20",
  "cvss_score": "Unknown",
  "nvd": "Unknown"
}